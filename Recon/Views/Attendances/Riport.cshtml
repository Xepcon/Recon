@*
    For more information on enabling MVC for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860
*@
@{
}
@using Microsoft.AspNetCore.Http

@inject IHttpContextAccessor HttpContextAccessor
<style>
    .hour-container {
        display: inline-block;
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
        width: 200px;
        height: 100px;
        margin-right: 10px;
        text-align: center;
        background-color: #6C63FF;
    }

    .hour-item {
        color: white;
        padding-top: 15px;
    }

    .hour-value-body {
        padding: 10px;
    }
</style>


<div id="person-selector"></div>

<div style="height:260px" id="range-selector"></div>


<div style="margin-top:50px; margin-bottom:100px!important;" id="chart"></div>

<div class="hour-container">
    <div class="hour-item">
        <h4>Ledolgozott órák</h4>
        <div class="hour-value-body">
            <p id="worked-label">42 óra 22 perc</p>
        </div>
    </div>
</div>
<div class="hour-container">
    <div class="hour-item">
        <h4>Szünetek</h4>
        <div class="hour-value-body">
            <p id="break-label">42 óra 22 perc</p>
        </div>
    </div>
</div>

<script>
    function hideChart(){
        $("#chart").hide();
        $(".hour-container").hide();
    }

    function ShowChart(){
        $("#chart").show();
        $(".hour-container").show();
    }
    var personsDataSource;
    var selectedPerson //= @HttpContextAccessor.HttpContext.Session.GetString("UserId");
    var GlobalstartDate;
    var GlobalendDate;
    var visible=false;
    var userid //= selectedPerson;
    $.ajax({
        url: '@Url.Content("~/ListGroupMembersForPrincipal")',
        method: "GET",
        async: false,
        success: function (data) {
            console.log(data);
            personsDataSource = new DevExpress.data.DataSource({
                store: data,
                key: "userId",
                paginate: true,
                pageSize: 10
            });

            $('#person-selector').dxSelectBox({
                dataSource: personsDataSource,
                displayExpr: 'name',
                valueExpr: 'userId',
                onValueChanged: function (e) {
                    console.log(e.value)
                    selectedPerson = e.value;
                    userid = selectedPerson;
                   
                    $.ajax({
                        url: "/api/UserCheckInGetter/" + userid + "?startDate=" + GlobalstartDate.toISOString() + "&endDate=" + GlobalendDate.toISOString(),
                        method: "GET",
                        success: function (data) {
                            ShowChart();
                            IntervalCalculate(data)

                        },
                        error: function (error) {
                            hideChart();
                        }
                    });
                }
            });
        },
        error: function (error) {
            // handle errors here
        }
    });


    $('#chart').dxChart({

        rotated: true,
        argumentAxis: {
            categories: ['Week days'],
            tick: {
                visible: false,
            },
        },
        title: {
            text: 'Kimutatás ',
        },
        valueAxis: {
            type: 'continuous',
            min: new Date(2022, 3, 1, 0),
            max: new Date(2022, 3, 2, 0),
            tickInterval: { minutes: 30 }
        },
        
        commonSeriesSettings: {
            argumentField: 'date',
            type: 'rangeBar',
            rangeValue1Field: 'start',
            rangeValue2Field: 'end',
            ignoreEmptyPoints: true,
            barOverlapGroup: 'date',
            barWidth: 10,

        },
        seriesTemplate: {
            nameField: 'type',

        },
        legend: {
            title: 'Ledogozott órák',
            verticalAlignment: 'bottom',
            horizontalAlignment: 'center',
        },
    });

    const chartInstance = $('#chart').dxChart('instance');

    var daytime;

    function IntervalCalculate(data) {


        const groupedData = data.reduce((acc, cur) => {
            const date = new Date(cur.date).toLocaleDateString();
            const time = new Date(cur.date).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });

            if (!acc[date]) {
                acc[date] = [{ start: time, end: time }];
            } else {
                const last = acc[date][acc[date].length - 1];
                if (last.end === time) {
                    last.end = time;
                } else {
                    acc[date].push({ start: time, end: time });
                }
            }

            return acc;
        }, {});

        const intervalsByDay = Object.entries(groupedData).reduce((acc, [date, times]) => {
            const intervals = times.map((time, i) => {
                const start = new Date(`${date} ${time.start}`);
                const end = new Date(`${date} ${time.end}`);
                return { start, end };
            });

            acc[date] = [];
            for (let i = 0; i < intervals.length - 1; i++) {
                acc[date].push({ start: intervals[i].end.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false }), end: intervals[i + 1].start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false }) });
            }

            return acc;
        }, {});



        const earliestLatestByDay = Object.entries(intervalsByDay).reduce((acc, [date, intervals]) => {
            var times = intervals.reduce((times, interval) => {
                times.push(interval.start, interval.end);
                return times;
            }, []);


            const uniqueTimes = [...new Set(times)];

            uniqueTimes.sort();


            const linearIntervals = [];

            for (let i = 0; i < uniqueTimes.length - 1; i++) {

                const [month, day, year] = date.split('/');
                const paddedMonth = month.padStart(2, '0');
                const paddedDay = day.padStart(2, '0');

                const start = new Date(`${year}-${paddedMonth}-${paddedDay}T${uniqueTimes[i]}`);
                const end = new Date(`${year}-${paddedMonth}-${paddedDay}T${uniqueTimes[i + 1]}`);

                linearIntervals.push({
                    start: start.toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    }),
                    end: end.toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    })
                });
            }

            acc[date] = linearIntervals;
            return acc;
        }, {});



        const output = [];
        var workedHours = 0;
        var workedMinutes = 0;

        var BreakHours = 0;
        var BreakMinutes = 0;
        Object.keys(earliestLatestByDay).forEach(date => {
            var counter = 0;
            earliestLatestByDay[date].forEach(interval => {
                const [startHour, startMinute] = interval.start.split(':');
                const [endHour, endMinute] = interval.end.split(':');
                const startDate = new Date(`$2022-02-01 ${startHour}:${startMinute}`);
                const endDate = new Date(`2022-02-01 ${endHour}:${endMinute}`);
                console.log(startDate)
                console.log(endDate)
                console.log(counter)
                
                if (counter % 2 == 0) {

                    workedHours += (endHour - startHour)
                    workedMinutes += (endMinute - startMinute)
                    output.push({
                        date,
                        start: startDate,
                        end: endDate,
                        type: 'Irodában'
                    });
                } else {
                    BreakHours += (endHour - startHour)
                    BreakMinutes += (endMinute - startMinute)
                    output.push({
                        date,
                        start: startDate,
                        end: endDate,
                        type: 'Szünet'
                    });
                }

                // }
                counter++;

            });
        });

      
        console.log(BreakHours)
        if (BreakMinutes < 0) {
            console.log("IF" + BreakHours)
            let mod = Math.ceil((BreakMinutes / 60));
            console.log("MODD" + mod)

            console.log("IF2" + BreakHours)
            if (mod == 0) {
                BreakHours = BreakHours - 1;
                console.log(BreakHours)
                BreakMinutes += 60
            } else {

            }
        }


        $("#worked-label").text(workedHours + " óra " + workedMinutes + " perc");
        $("#break-label").text(BreakHours + " óra " + BreakMinutes + " perc");
        chartInstance.option('dataSource', output);
        //console.log(output);

    }



    

    /*
    $.ajax({
        url: "/api/UserCheckInGetter/daytime/" + userid,
        method: "GET",
        success: function (data) {
            //console.log('Daytime API data:', data);
            daytime = data

        },
        error: function (error) {
            // handle errors here
        }
    });*/



    $(function () {

        var rangeSelector = $("#range-selector").dxRangeSelector({
            margin: {
                top: 50,
            },
            scale: {
                startValue: new Date(2022, 1, 1),
                endValue: new Date(2022, 12, 1),
                minorTickInterval: 'day',
                tickInterval: 'week',
                minRange: 'day',
                maxRange: 'month',
                minorTick: {
                    visible: false,
                },
            },
            sliderMarker: {
                format: 'monthAndDay',
            },
            value: [new Date(2022, 1, 28), new Date(2022, 2, 7)],
            title: 'Válasz ki egy intervallumot',

            onValueChanged: function (e) {
                console.log(userid)
                GlobalendDate = e.value[1]
                GlobalstartDate = e.value[0]
                var startDate = e.value[0];
                var endDate = e.value[1];
                var days = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
                if (userid != undefined) {
                    $.ajax({
                        url: "/api/UserCheckInGetter/" + userid + "?startDate=" + startDate.toISOString() + "&endDate=" + endDate.toISOString(),
                        method: "GET",
                        success: function (data) {
                            ShowChart();
                            IntervalCalculate(data)
                        },
                        error: function (error) {
                            hideChart();
                        }
                    });
                } else {
                    hideChart();
                }

            }
        }).dxRangeSelector("instance");

    });
    $(document).ready(function () {
        GlobalendDate =  new Date(2022, 2, 7);
        GlobalstartDate = new Date(2022, 1, 28);
        var startDate = new Date(2022, 1, 28);
        var endDate = new Date(2022, 2, 7);
        var days = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
        if(userid!=undefined){
            $.ajax({
                url: "/api/UserCheckInGetter/" + userid + "?startDate=" + startDate.toISOString() + "&endDate=" + endDate.toISOString(),
                method: "GET",
                success: function (data) {
                    ShowChart();
                    IntervalCalculate(data)
                },
                error: function (error) {
                   hideChart();
                }
            });
        }else{
            hideChart();
        }
    });
</script>