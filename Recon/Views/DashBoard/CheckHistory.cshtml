@*
    For more information on enabling MVC for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860
*@
@{
}
<style>
    .hour-container {
        display: inline-block;
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
        width: 200px;
        height: 100px;
        margin-right: 10px;
        text-align: center;
        
        background-color: #6C63FF;
    }

    .hour-item {
        
        color: white;
        padding-top:15px;
    }

    .hour-value-body {
        padding: 10px;
    }
</style>

@using Microsoft.AspNetCore.Http

@inject IHttpContextAccessor HttpContextAccessor

<div style="height:260px"id="range-selector"></div>


<div style="margin-top:50px; margin-bottom:100px!important;" id="chart"></div>

<div class="hour-container">      
    <div class="hour-item">            
        <h4>Ledolgozott órák</h4>  
        <div class="hour-value-body">
            <p id="worked-label">42 óra 22 perc</p>
        </div>
    </div>       
</div>
<div class="hour-container">      
    <div class="hour-item">            
        <h4>Szünetek</h4>  
        <div class="hour-value-body">
            <p id="break-label">42 óra 22 perc</p>
        </div>
    </div>       
</div>

<script>

       
    $('#chart').dxChart({
        
        rotated: true,
        argumentAxis: {
            categories: ['Week days'],
            tick: {
                visible: false,
            },
        },
        title: {
            text: 'Heti kimutatás ',
        },
        valueAxis: {
            type: 'continuous',
            min: new Date(2022, 3, 1, 0),
            max: new Date(2022, 3, 2, 0),
            tickInterval: { minutes: 30 }
        },
        commonSeriesSettings: {
            argumentField: 'date',
            type: 'rangeBar',
            rangeValue1Field: 'start',
            rangeValue2Field: 'end',
            ignoreEmptyPoints: true,
            barOverlapGroup: 'date',
            barWidth: 10,

        },
        seriesTemplate: {
            nameField: 'type',

        },
        legend: {
            title: 'Ledogozott órák',
            verticalAlignment: 'bottom',
            horizontalAlignment: 'center',
        },
    });

    const chartInstance = $('#chart').dxChart('instance');
    
    var daytime;  

    function IntervalCalculate(data){
        
        
        const groupedData = data.reduce((acc, cur) => {
            const date = new Date(cur.date).toLocaleDateString();
            const time = new Date(cur.date).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });

            if (!acc[date]) {
                acc[date] = [{ start: time, end: time }];
            } else {
                const last = acc[date][acc[date].length - 1];
                if (last.end === time) {
                    last.end = time;
                } else {
                    acc[date].push({ start: time, end: time });
                }
            }

            return acc;
        }, {});
      
        const intervalsByDay = Object.entries(groupedData).reduce((acc, [date, times]) => {
            const intervals = times.map((time, i) => {
                const start = new Date(`${date} ${time.start}`);
                const end = new Date(`${date} ${time.end}`);
                return { start, end };
            });

            acc[date] = [];
            for (let i = 0; i < intervals.length - 1; i++) {
                acc[date].push({ start: intervals[i].end.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false }), end: intervals[i + 1].start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false }) });
            }

            return acc;
        }, {});
      
        

        const earliestLatestByDay = Object.entries(intervalsByDay).reduce((acc, [date, intervals]) => {
            var times = intervals.reduce((times, interval) => {
                times.push(interval.start, interval.end);
                return times;
            }, []);

        
            const uniqueTimes = [...new Set(times)];
            
            uniqueTimes.sort();
            
            
            const linearIntervals = [];
           
            for (let i = 0; i < uniqueTimes.length - 1; i++) {
                
                const [month, day, year] = date.split('/');
                const paddedMonth = month.padStart(2, '0');
                const paddedDay = day.padStart(2, '0');
               
                const start = new Date(`${year}-${paddedMonth}-${paddedDay}T${uniqueTimes[i]}`);
                const end = new Date(`${year}-${paddedMonth}-${paddedDay}T${uniqueTimes[i + 1]}`);
                
                linearIntervals.push({
                    start: start.toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    }),
                    end: end.toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    })
                });
            }     
            
            acc[date] = linearIntervals;
            return acc;
        }, {});
        
       

        const output = [];
        var workedHours = 0;
        var workedMinutes = 0;

        var BreakHours = 0;
        var BreakMinutes = 0;
        Object.keys(earliestLatestByDay).forEach(date => {
            var counter = 0;
            earliestLatestByDay[date].forEach(interval => {
                const [startHour, startMinute] = interval.start.split(':');
                const [endHour, endMinute] = interval.end.split(':');
                const startDate = new Date(`$2022-02-01 ${startHour}:${startMinute}`);
                const endDate = new Date(`2022-02-01 ${endHour}:${endMinute}`);
                console.log(startDate)
                console.log(endDate)
                console.log(counter)
                /*if (startDate.getHours() > 11 && endDate.getHours()<14) {
                   
                    output.push({
                        date,
                        start: startDate,
                        end: endDate,
                        type: 'lunch'
                    });
                }else{*/
                    if(counter%2==0){
                    
                    workedHours += (endHour - startHour )
                    workedMinutes += (endMinute - startMinute)
                        output.push({
                            date,
                            start: startDate,
                            end: endDate,
                            type: 'Irodában'
                        });
                    }else{
                    BreakHours += (endHour - startHour)
                    BreakMinutes += (endMinute - startMinute)
                         output.push({
                        date,
                        start: startDate,
                        end: endDate,
                        type: 'Szünet'
                    });
                    }
                   
               // }
                counter++;
                
            });
        });
        
        /*console.log(workedHours);
        console.log(workedMinutes);

        console.log(BreakHours);
        console.log(BreakMinutes);*/
        console.log(BreakHours)
        if (BreakMinutes < 0) {
            console.log("IF"+BreakHours)
            let mod = Math.ceil((BreakMinutes / 60));
            console.log("MODD"+mod)
            
            console.log("IF2" + BreakHours)
            if (mod == 0) {
                BreakHours = BreakHours - 1;
                console.log(BreakHours)
                BreakMinutes += 60
            }
        }


        $("#worked-label").text(workedHours+" óra "+workedMinutes+" perc");
        $("#break-label").text(BreakHours + " óra " + BreakMinutes + " perc");
        chartInstance.option('dataSource', output);
        //console.log(output);
       
    }

   

    var userid = @HttpContextAccessor.HttpContext.Session.GetString("UserId");
  
   
     $.ajax({
        url: "/api/UserCheckInGetter/daytime/" + userid,
        method: "GET",
        success: function (data) {
            //console.log('Daytime API data:', data);
            daytime = data
            
        },
        error: function (error) {
            // handle errors here
        }
    });

  

    $(function () {               

       var rangeSelector = $("#range-selector").dxRangeSelector({
        margin: {
            top: 50,
        },
        scale: {
            startValue: new Date(2022, 1, 1),
            endValue: new Date(2022, 12, 1),
            minorTickInterval: 'week',
            tickInterval: 'week',
            minRange: 'week',
            maxRange: 'week',
            minorTick: {
                visible: false,
            },
        },
        sliderMarker: {
            format: 'monthAndDay',
        },
        value: [new Date(2022, 1, 28), new Date(2022, 2, 7)],
        title: 'Válasz ki egy intervallumot',

            onValueChanged: function (e) {
                var startDate = e.value[0];
                var endDate = e.value[1];
                var days = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
                $.ajax({
                    url: "/api/UserCheckInGetter/" + userid + "?startDate=" + startDate.toISOString() + "&endDate=" + endDate.toISOString(),
                    method: "GET",
                    success: function(data) {
                       
                        IntervalCalculate(data)
                      
                    },
                    error: function(error) {
                       
                    }
                });
              
        }
    }).dxRangeSelector("instance");

    });
    $(document).ready(function () {
        var startDate = new Date(2022, 1, 28);
        var endDate = new Date(2022, 2, 7);
        var days = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
        $.ajax({
            url: "/api/UserCheckInGetter/" + userid + "?startDate=" + startDate.toISOString() + "&endDate=" + endDate.toISOString(),
            method: "GET",
            success: function (data) {
                IntervalCalculate(data)
            },
            error: function (error) {
            }
        });
    });
</script>