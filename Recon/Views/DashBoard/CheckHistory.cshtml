@*
    For more information on enabling MVC for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860
*@
@{
}


@using Microsoft.AspNetCore.Http

@inject IHttpContextAccessor HttpContextAccessor

<div style="height:260px"id="range-selector"></div>


<div style="margin-top:50px" id="chart"></div>


<script>

     
     
    $('#chart').dxChart({
        
        rotated: true,
        argumentAxis: {
            categories: ['Week days'],
            tick: {
                visible: false,
            },
        },
        title: {
            text: 'Weekly report',
        },
        valueAxis: {
            type: 'continuous',
            min: new Date(2022, 3, 1, 0),
            max: new Date(2022, 3, 2, 0),
            tickInterval: { minutes: 30 }
        },
        commonSeriesSettings: {
            argumentField: 'date',
            type: 'rangeBar',
            rangeValue1Field: 'start',
            rangeValue2Field: 'end',
            ignoreEmptyPoints: true,
            barOverlapGroup: 'date',
            barWidth: 10,

        },
        seriesTemplate: {
            nameField: 'type',

        },
        legend: {
            title: 'Working Hour',
            verticalAlignment: 'bottom',
            horizontalAlignment: 'center',
        },
    });

    const chartInstance = $('#chart').dxChart('instance');
    
    var daytime;  

    function IntervalCalculate(data){
        
        
        const groupedData = data.reduce((acc, cur) => {
            const date = new Date(cur.date).toLocaleDateString();
            const time = new Date(cur.date).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });

            if (!acc[date]) {
                acc[date] = [{ start: time, end: time }];
            } else {
                const last = acc[date][acc[date].length - 1];
                if (last.end === time) {
                    last.end = time;
                } else {
                    acc[date].push({ start: time, end: time });
                }
            }

            return acc;
        }, {});
      
        const intervalsByDay = Object.entries(groupedData).reduce((acc, [date, times]) => {
            const intervals = times.map((time, i) => {
                const start = new Date(`${date} ${time.start}`);
                const end = new Date(`${date} ${time.end}`);
                return { start, end };
            });

            acc[date] = [];
            for (let i = 0; i < intervals.length - 1; i++) {
                acc[date].push({ start: intervals[i].end.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false }), end: intervals[i + 1].start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false }) });
            }

            return acc;
        }, {});
      
        

        const earliestLatestByDay = Object.entries(intervalsByDay).reduce((acc, [date, intervals]) => {
            var times = intervals.reduce((times, interval) => {
                times.push(interval.start, interval.end);
                return times;
            }, []);

        
            const uniqueTimes = [...new Set(times)];
            
            uniqueTimes.sort();
            
            
            const linearIntervals = [];
           
            for (let i = 0; i < uniqueTimes.length - 1; i++) {
                
                const [month, day, year] = date.split('/');
                const paddedMonth = month.padStart(2, '0');
                const paddedDay = day.padStart(2, '0');
               
                const start = new Date(`${year}-${paddedMonth}-${paddedDay}T${uniqueTimes[i]}`);
                const end = new Date(`${year}-${paddedMonth}-${paddedDay}T${uniqueTimes[i + 1]}`);
                
                linearIntervals.push({
                    start: start.toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    }),
                    end: end.toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    })
                });
            }     
            
            acc[date] = linearIntervals;
            return acc;
        }, {});
        
       

        const output = [];
       
        Object.keys(earliestLatestByDay).forEach(date => {
            var counter = 0;
            earliestLatestByDay[date].forEach(interval => {
                const [startHour, startMinute] = interval.start.split(':');
                const [endHour, endMinute] = interval.end.split(':');
                const startDate = new Date(`$2022-02-01 ${startHour}:${startMinute}`);
                const endDate = new Date(`2022-02-01 ${endHour}:${endMinute}`);
                console.log(startDate)
                console.log(endDate)
                console.log(counter)
                /*if (startDate.getHours() > 11 && endDate.getHours()<14) {
                   
                    output.push({
                        date,
                        start: startDate,
                        end: endDate,
                        type: 'lunch'
                    });
                }else{*/
                    if(counter%2==0){
                        output.push({
                            date,
                            start: startDate,
                            end: endDate,
                            type: 'inoffice'
                        });
                    }else{
                         output.push({
                        date,
                        start: startDate,
                        end: endDate,
                        type: 'break'
                    });
                    }
                   
               // }
                counter++;
                
            });
        });
        chartInstance.option('dataSource', output);
        //console.log(output);
       
    }

   

    var userid = @HttpContextAccessor.HttpContext.Session.GetString("UserId");
  
   
     $.ajax({
        url: "/api/UserCheckInGetter/daytime/" + userid,
        method: "GET",
        success: function (data) {
            //console.log('Daytime API data:', data);
            daytime = data
            
        },
        error: function (error) {
            // handle errors here
        }
    });

  

    $(function () {               

       var rangeSelector = $("#range-selector").dxRangeSelector({
        margin: {
            top: 50,
        },
        scale: {
            startValue: new Date(2022, 1, 1),
            endValue: new Date(2022, 12, 1),
            minorTickInterval: 'week',
            tickInterval: 'week',
            minRange: 'week',
            maxRange: 'week',
            minorTick: {
                visible: false,
            },
        },
        sliderMarker: {
            format: 'monthAndDay',
        },
        value: [new Date(2022, 1, 5), new Date(2022, 1, 12)],
        title: 'Select a week period',

            onValueChanged: function (e) {
                var startDate = e.value[0];
                var endDate = e.value[1];
                var days = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
                $.ajax({
                    url: "/api/UserCheckInGetter/" + userid + "?startDate=" + startDate.toISOString() + "&endDate=" + endDate.toISOString(),
                    method: "GET",
                    success: function(data) {
                       
                        IntervalCalculate(data)
                      
                    },
                    error: function(error) {
                       
                    }
                });
              
        }
    }).dxRangeSelector("instance");

    });
</script>